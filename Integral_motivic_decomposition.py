''' This script computes combinatorial model of endomorphism ring of the Chow motive of a versal homogenous space
with Z coefficients.
To run this script you will need to have sage and python installed.
To run the script use the following command:
    sage -python Motivic_decompoisions.py
Notation:
p = characteristic of the coefficient field F_p
W= Weyl group
I_P = list of simple roots defining a parabolic subgroup P
W_P = subgroup of W generated by I_P
WP = list of minimal coset representatives of W/W_P
sP = list of simple reflections s_i for i in I_P
max_length = maximal length of elements in WP
length_list = list of  lists of elements of WP of given length:
                length_list[i] = list of elements of WP of length i
s = list of simple reflections
e = identity element
block_dim = list of dimensions of diagonal blocks in the endomorphism block_matrix
                block_dim[i] = number of elements of WP of length i

pivots = list of all pivot elements in WP. An element w of WP is pivot, if it cannot
                be presented as w=s_iw' for w' in WP, l(w')>l(w) and i in I_P

ring S
'''


from sage.all import *
import itertools
import json
import pickle
from progressbar import progressbar

global L,I_P,Cartan, W, WP, reduced,w0,e,s,sP,max_length,length_list, block_dim, pivots, raising,S,a,Hasse

def init(L_inp,I_Pinp):
    global L,I_P,Cartan, W, WP, reduced,w0,e,s,sP,max_length,length_list, block_dim, pivots, raising,S,a,Hasse
    L=L_inp
    I_P=I_Pinp
    Cartan=CartanMatrix(L)
    W=WeylGroup(L)
    reduced=dict([(w,(w.reduced_word())) for w in W])
    w0=W.long_element()
    e=W.unit()
    s=W.simple_reflections()
    sP=[s[i] for i in I_P]

    def is_minimal(w,I_P):
        return all((w*s[i]).length()>=w.length() for i in I_P)
    WP=[w for w in W if is_minimal(w,I_P)]
    max_length=max([w.length() for w in WP])
    length_list=[[w for w in WP if w.length()==i] for i in range(0, max_length+1)]
    block_dim=[len(length_list[i]) for i in range(0, max_length+1)]

    def pivot_conditions(w):
        return [(s[i]*w).length()<w.length() or (s[i]*w not in WP) for i in I_P]
    pivots=[w for w in WP if all(pivot_conditions(w))]

    raising={}
    for w in pivots:
        raising[w]=[i for i in I_P if (s[i]*w).length()==w.length()+1]

    def torus_equivariant_cohomology(L):
        a=['a'+str(r) for r in range(1,L.rank()+1)]
        S=PolynomialRing(ZZ,a)
        S.inject_variables()
        return S, [S.gens_dict()['a'+str(i)] for i in range(1,L.rank()+1)]

    def Hasse_diagram(L,I_P):
        ans=dict([(w,[]) for w in WP])
        for w in WP:
            ans[w]=[i for i in range(1,len(s)+1) if ((s[i]*w).length()==w.length()+1 and s[i]*w in WP)]
        return ans
    Hasse=Hasse_diagram(L,I_P)
    S,a=torus_equivariant_cohomology(L)
    a=[None]+a # to start indexing from1

    return [Cartan, W, WP, reduced,w0,e,s,sP,max_length,length_list, block_dim, pivots, raising,S,a,Hasse]


# Returns the equivariant Chow ring of Spec k and the list of simple roots a_i.
# raising=dictionary with keys = pivots, and raising[w]=list of indices i in I_P such that l(s_iw)=l(w)+1
#print('initializing global variables..')
#Cartan, W, WP, reduced,w0,e,s,sP,max_length,length_list, block_dim, pivots, raising,S,a,Hasse=init(L,p,I_P)
#print('initializing complete')

#Hasse diagram stores a dictionary with keys=WP and Hasse[w]=list of all simple reflections s_i such that
#s_iw has bigger length and s_iw is in WP, (so left multiplication by s_i leads to the next node in Hasse diagram)




# Returns the reflection of f in S with respect to the simple root a_n
def reflection(f,n):
    return f(tuple([a[i]-Cartan[n-1,i-1]*a[n] for i in range(1, (L.rank()+1))]))
# Returns the result of application of Demzure operator Delta_i to f in S
def Delta(f,n):
    return (f-reflection(f,n))//a[n]




#---------------------------------------------
#Constricting of endomorphisms of DP^* By ~add ref~ every endomorphism F
#is determined by its value
#F([pt])=sum_{w in WP} a_wX_w (*)
#for a_w in S, deg(a_w)=l(w).
#By~add refernce~ the values a_w in decomposition (*) are fully determined by
#a_v where v are pivot elements in WP
# Function propagate extends the coefficient from pivots a_v to all elements a_w
# Input: dictionary with keys w in WP, Output: dictionary with keys w in WP with values
# extended from the pivot values using the procedure described in ~add reference~
def propagate(f):
    ans=f
    def descend(w):
        for i in I_P:
            if (s[i]*w).length()<w.length():
                ans[s[i]*w]=-Delta(ans[w],i)
                descend(s[i]*w)
    for w in pivots:
        descend(w)
    return ans

# function returns the list of all monomials in S of degree deg in lexicographic order
def monomial(deg):
    partitions=list(WeightedIntegerVectors(deg, [1 for i in range(0,L.rank())]))
    return [S({tuple(partition[::-1]):1}) for partition in partitions]


#function that returns a matrix of n-th simple reflection on the space
#of homogeneous polynomials of degree deg in basis of monomials
#s_n(f_j)=sum M[i,j]f_i where f_i is the ith monomial of degree deg.
def reflection_matrix(deg,n):
    mons=monomial(deg)
    size=len(mons)
    m=matrix(ZZ,size,size)
    for i in range(0,size):
        for j in range(0,size):
            m[j,i]=reflection(mons[i],n).monomial_coefficient(mons[j])
    return m

# Function that returns the basis of the space of homogeneous polynomials
# of degree deg that are invariant for every simple reflection in reflections
# reflections is the list of numbers of simple reflections

# old version - overflows the stack
#def invariant_polynomials_basis(deg,reflections):
#    if deg<0:
#        return []
##        mons=monomial(deg)
#        size=len(mons)
#        if reflections==[]:
#            return mons
#        else:
#            stackmatrix=block_matrix(len(reflections),1,[(matrix.identity(ZZ,size)-reflection_matrix(deg,j)) for j in reflections])
#            vectors=stackmatrix.right_kernel().basis()
#            ans=[(sum(v[i]*mons[i] for i in range(len(v)))) for v in vectors]
#            return ans

def invariant_polynomials_basis(deg,reflections):
    if deg<0:
        return []
    else:
        mons=monomial(deg)
        size=len(mons)
        if reflections==[]:
            return mons
        else:
            space0=(matrix.identity(ZZ,size,sparse=True)-reflection_matrix(deg,reflections[0])).right_kernel()
            for j in range(1,len(reflections)):
                space1=(matrix.identity(ZZ,size,sparse=True)-reflection_matrix(deg,reflections[j])).right_kernel()
                space0=space0.intersection(space1)
            vectors=space0.basis()
            ans=[(sum(v[i]*mons[i] for i in range(len(v)))) for v in vectors]
            return ans


#Function that returns diagonal block of endomorphism defined by f,w for pivot w and polynomial f
#Output=list of matrices list is indexed by i between 0 and max_length, the i-th matrix has size
#equal to the number of elements in WP of length i.
def endomorphism_diagonal(F):
    ans=[0 for i in range(0,max_length+1)]
    for i in range(0,max_length+1):
        size=len(length_list[i])
        ans[i]=matrix(S,size)
        for k in range(0,len(length_list[i])):
            for m in range(0,len(length_list[i])):
                ans[i][k,m]=F[(length_list[i][k],length_list[i][m])]
    return ans


#Function that returns all pairs w,f that index basis endomorphisms:
# w is pivot, and f is a basis element of the space of polynomials of degee length(w)
# that are invariant under reflections in raising[w]
# returns the indices of basis of the space of endomorphisms of degree deg
def endomorphism_basis_indices(deg):
    return [(w,f) for w in progressbar(pivots) for f in invariant_polynomials_basis(w.length()+deg,raising[w])]

def identity_index():
    return (e,a[1]//a[1])

# Basis of the space of endomorphisms corresponds to the pairs (w,f) where w in WP is a pivot element and
# f is a basis element in the space of polynomial of degree l(w) in S, invariant under action of any s_i in raising[w]

#Function that constructs the matrix of an endomorphism F with F(pt)=fX_w for a pivot w and f in S.
def endomorphism(w,f,deg):
    first_column_dictionary=dict([(ww,a[1]-a[1]) for ww in WP])
    first_column_dictionary[w]=f
    first_column_dictionary=propagate(first_column_dictionary)
    M=dict([((v,w),0) for v in WP for w in WP])
    for v in WP:
        M[(v,e)]=first_column_dictionary[v]
    for length in range (0,max_length+1):
        for w in length_list[length]:
            for i in Hasse[w]:
                for v in WP:
                    if (s[i]*v).length()==v.length()+1:
                        M[v,s[i]*w]=Delta(M[v,w],i)
                    elif (s[i]*v).length()==v.length()-1:
                        M[v,s[i]*w]=reflection(M[s[i]*v,w],i)+Delta(M[v,w],i)
    return M

def augmented_endomorphism(w,f,deg):
    M=dict([((v,w),0) for v in WP for w in WP])
    F=endomorphism(w,f,deg)
    for v in WP:
        for w in length_list[v.length()+d]:
            M[w,v]=F[w,v]

def augmented_diagonal(w,f,d):
    F=endomorphism(w,f,d)
    ans=[None for l in range(0,max_length+1-max(d,-d))]
    if d>=0:
        for l in range(0,max_length+1-d):
            ans[l]=matrix(S,len(length_list[l]),len(length_list[l+d]))
            for k in range(0,len(length_list[l])):
                for m in range(0,len(length_list[l+d])):
                    ans[l][k,m]=F[(length_list[l][k],length_list[l+d][m])]
    elif d<0:
        for l in range(0,max_length+1+d):
            ans[l]=matrix(S,len(length_list[l-d]),len(length_list[l]))
            for k in range(0,len(length_list[l-d])):
                for m in range(0,len(length_list[l])):
                    ans[l][k,m]=F[(length_list[l-d][k],length_list[l][m])]
    return ans

def identity_diagonal():
    return augmented_diagonal(e,a[1]//a[1],0)

def zero_diagonal():
    return augmented_diagonal(e,a[1]-a[1],0)

def diagonal_is_zero(D):
    return (all(a==matrix(S,a.nrows(),a.ncols()) for a in D))

#computes the  square of the diagonal block matrix
def square(D):
    return [a*a for a in D]


# returns i,j block of degree d diagonal matrix D.
def block(D,d,i,j):
    assert(i-j==d)
    if d>=0:
        if j>=0:
            return D[j]
        else:
            return 0
    else:
        if i>=0:
            return D[i]
        else:
            return 0

#multiplies two block matrices homog of degrees deg1 and deg2
def diagonal_multiply(D1,D2,deg1,deg2):
    d=deg1+deg2
    ans=[None for l in range(0,max_length+1-max(d,-d))]
    if d>=0:
        for l in range(0,max_length+1-d):
            ans[l]=block(D1,deg1,d+l,deg2+l)*block(D2,deg2,deg2+l,l)
    elif d<0:
        for l in range(0,max_length+1+d):
            ans[l]=block(D1,deg1,l,l-deg1)*block(D2,deg2,l-deg1,l-d)
    return (ans,d)

def add(D1,D2):
    assert (len(D1)==len(D2))
    return[D1[i]+D2[i] for i in range(0,len(D1))]

#projects endomorphism onto direct summand given by idempotent p
def project(D,deg,p):
    left, d=diagonal_multiply(p,D,0,deg)
    right, d=diagonal_multiply(left,p,deg,0)
    return right

def is_idempotent(D):
    return D==square(D)

def id_complement(D):
    return [matrix.identity(S,x.nrows())-x for x in D]




#######################################################################
#Additional functions to help search for idempotents
# removes duplicates from list of diagonals
def remove_duplicates(A):
    A.sort()
    B=list(x for x,_ in itertools.groupby(A))
    return B

#procedure that check endomorphisms from the list 'diagonals' for being idempotent.
#If it finds an idempotent in the list diagonals, it projects endomorphisms from 'diagonals'
#on corresponding summands and checks if the projections are idempotent and so on.
#For correct output the list diagonals should contain zero,and identity.
def basis_idempotents(diagonals,identity):
    diagonals=remove_duplicates(diagonals)
    ids=[x for x in diagonals if is_idempotent(x)]
    if len(ids)<=2:
        return ids
    else:
        p=ids[0]
        if p==zero_diagonal() or p==identity:
            p=ids[1]
            if p==zero_diagonal() or p==identity:
                p=ids[2]
        q=id_complement(p)
        pro1=[project(x,0,p) for x in diagonals]
        pro2=[project(x,0,q) for x in diagonals]
        list1=basis_idempotents(pro1,p)
        list2=basis_idempotents(pro2,q)
        list1.extend(list2)
        return remove_duplicates(list1)






#indices=endomorphism_basis_indices()
#for index in indices:
#    print(endomorphism_diagonal(index[0],index[1]))
#blocks=dict([(index,endomorphism_diagonal(DP_endomorphism(index[0],index[1])))  for index in progressbar(indices)])
#print(blocks)
#save(blocks,'G2blocks')
#pickle.dump(blocks, open( "A3blocks.p", "wb" ) )
#newblocks=load('G2blocks.sobj')
#print(blocks==newblocks)

#print('dimension of space of endomoprhisms is '+str(len(indices)))
